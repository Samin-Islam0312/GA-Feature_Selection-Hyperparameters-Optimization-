# -*- coding: utf-8 -*-
"""Genetic Algorithm

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18J-N9EtF__Z4LsCACCeeHHrBci9mTqGk

Genetic Algorithm -
 * Randomly initialize a population
 * Evaluate fitness of population
 * Repeat
---

* Select parents from population
* Crossover on parents for creating new set of population
* Mutation on the population
* Evaluate fitness of population

---
Repeat - repeat until best solution is provided

Problem Statement - finding an optimum solution to generate an array with a number ranging between 0 and 9 that will have a sum less than or equal to 11.
"""

import numpy as np
from random import randint, random, choice
limit = 11
generations = 1000
no_of_best_solutions = 5
solutions_in_a_generation = 10
size_of_solution = 10
low = 0
up = 10

def generate_population(no_of_solution, size, lower, upper):
    solution = []
    population=[]
    for i in range(no_of_solution):
        #Create a chromosome or solution for the population.        
        solution=[randint(lower,upper) for x in range(size) ]       
        population.append(solution)
    return population


def fitness(individual):
   #fitness - Lower is better.
   total_list_sum = sum(individual)
   return np.abs(total_list_sum - limit)


def sort_population(population):
    return sorted(population, key=fitness, reverse=False)

def crossover(a, b):
    new_variant=[]
    first=randint(2,8)
    new_variant= a[:first] + b[first:]
    return new_variant

def mutate(individual):
    new_list=[]
    first=randint(0,9)
    second=randint(0,9)
    third=randint(0,9)
    individual[first]=randint(0,9)
    individual[second]=randint(0,9)
    individual[third]=randint(0,9)
    return individual

def make_next_generation(previous_population):
    next_generation = []
    sorted_by_fitness_population = sort_population(previous_population)
    population_size = len(previous_population)
   
    for i in range(population_size):
        # find the least loss in the fitness function among the population
        for j in range(0,no_of_best_solutions):
            pick_best_parents= randint(0,no_of_best_solutions-2)
            parent_1=sorted_by_fitness_population[pick_best_parents]
            parent_2=sorted_by_fitness_population[pick_best_parents+1]
            best_parent_1=sorted_by_fitness_population[0]
            best_parent_2=sorted_by_fitness_population[1]
        draw = choice(["crossover", "mutate_parent1", "mutate_parent2", 
                       "Parent 1", "Parent 2","best 1", "best 2" ])
        if draw=="crossover":
            individual = crossover(parent_1, parent_2)
        elif draw=="mutate_parent1":
            individual = mutate(parent_1)
        elif draw=="mutate_parent2":
             individual = mutate(parent_2)
        elif draw=="Parent 1":
             individual =parent_1
        elif draw=="Parent 2":
             individual =parent_2
        elif draw=="best 1":
             individual =best_parent_1
        elif draw=="best 2":
             individual =best_parent_2
        
        next_generation.append(individual)
    
    return next_generation


best_solution=[]
population_data=generate_population(solutions_in_a_generation,size_of_solution,low, up)
# find the least loss in the fitness function among the population
best_individual = sort_population(population_data)
if fitness(best_individual[0])<=1:
    best_solution=best_individual[0]
else:
    for gen in range(generations):
        population_data=make_next_generation(population_data)
        best_individual = sort_population(population_data)
        print(best_individual)

        if fitness(best_individual[0])<=1:
            best_solution=best_individual[0]
            print(best_solution)
            break
print("FINAL RESULT",best_solution,"with fitness",fitness(best_solution),"at generation",gen)